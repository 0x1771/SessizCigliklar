module.exports = "#define GLSLIFY 1\n/* \nuniform vec2 resolution;\nuniform vec2 texelSize;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float aspect;\nuniform float time;\nuniform sampler2D inputBuffer;\nuniform sampler2D depthBuffer; \n*/\n\nuniform float strength;\n\n" + require('glsl-noise/simplex/3d.glsl') + " \n\nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\n/* \nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n} */\n\nfloat curve(float t) {\n    return t * t * t;\n}\n\nfloat quintCurveOut(float t) {\n    //return  1. - --t * t * t * t;\n    return  1. + --t * t * t * t * t;\n}\n\nvoid mainImage( in vec4 fragColor, in vec2 uv, out vec4 outputColor )\n{\n    float ratio = resolution.x / resolution.y;\n    vec2 uvR = vec2(uv.x, uv.y / ratio);\n    \n    float d = curve(distance(uv, vec2(0.5))) * 4.5;\n\n    float n0 = quintCurveOut(snoise(vec3(uvR * 1.5, time * .085)));\n    float n1 = quintCurveOut(snoise(vec3(uvR * 1.5, time * .09 + 2.5)));\n    \n    vec3 grey = vec3(.5, .5, .5);\n    vec3 blue = vec3(104./255., 148./255., 171./255.) * n0;\n    vec3 orange = vec3(255./255., 174./255., 0./255.) * n1;\n\n    vec3 vignette = blendScreen( orange, blue, 1.) * d;\n    vignette = clamp(vignette, 0., 1.);\n   // vignette = blendScreen(vignette, vec3(.5, .5, .5), 1.);\n\n    outputColor = vec4(vignette * strength, 1.);\n    //utputColor = vec4(blue, 1.);\n}\n";